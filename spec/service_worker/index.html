<!DOCTYPE html>
<html lang="en">
<head>
<title>Service Workers</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<link rel="stylesheet" href="../assets/styles/main.css" type="text/css">
<link rel="stylesheet" href="../assets/styles/spec.css" type="text/css">
<link rel="stylesheet" href="../assets/styles/prettify.css" type="text/css">
<link rel="stylesheet" href="../assets/styles/third_party/W3C-ED.css" type="text/css" >
<script src="../assets/scripts/bug-assist.js"></script>
<script src="../assets/scripts/spec-assist.js"></script>
<script src="../assets/scripts/prettify.js"></script>
<!-- <meta name="bug.blocked" content="14968"> -->
<meta name="bug.short_desc" content="[ServiceWorker]: ">
<meta name="bug.product" content="WebAppsWG">
<meta name="bug.component" content="ServiceWorker">
</head>

<body>

<div class="head">

<div class="logo">
    <a href="//www.w3.org/"><img width="72" height="48" src="//www.w3.org/Icons/w3c_home" alt="W3C"></a>
</div>

<h1>Service Workers</h1>
<h2 id="editors-draft">W3C Editor's Draft</h2>
<dl>
<dt>This version</dt>
    <dd><a href="https://github.com/slightlyoff/ServiceWorker/tree/master/spec/service_worker/index.html">https://github.com/slightlyoff/ServiceWorker/tree/master/spec/service_worker/index.html</a></dd>
<dt>Latest editor's draft</dt>
    <dd><a href="https://github.com/slightlyoff/ServiceWorker/tree/master/spec/service_worker/index.html">https://github.com/slightlyoff/ServiceWorker/tree/master/spec/service_worker/index.html</a></dd>
<dt>Previous version</dt>
    <dd><a href="http://www.w3.org/TR/service-workers/">http://www.w3.org/TR/service-workers/</a></dd>
<dt>Revision history</dt>
    <dd><a id="log" href="https://github.com/slightlyoff/ServiceWorker/commits/master">https://github.com/slightlyoff/ServiceWorker/commits/master</a></dd>
<dt>Participate</dt>
    <dd>Discuss on <a href="http://lists.w3.org/Archives/Public/public-webapps/">public-webapps@w3.org</a> (<a href="http://www.w3.org/2008/webapps/">Web Applications Working Group</a>)</dd>
    <dd><a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?comment=&amp;blocked=14968&amp;short_desc=%5BCustom%5D%3A%20&amp;product=WebAppsWG&amp;component=Service%20Workers">File bugs</a> (w3.org's <a href="https://www.w3.org/Bugs/Public/">Bugzilla</a>)</dd>
<dt>Editors</dt>
    <dd class="vcard"><span class="fn">Alex Russell</span>, <span class="org">Google</span>, &lt;<a class="email" href="mailto:slightlyoff@chromium.org">slightlyoff@chromium.org</a>&gt;</dd>
    <dd class="vcard"><span class="fn">Jungkee Song</span>, <span class="org">Samsung Electronics</span>, &lt;<a class="email" href="mailto:slightlyoff@chromium.org">jungkee.song@samsung.com</a>&gt;</dd>
</dl>

<p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &copy; 2014 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>&copy;</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>), All Rights Reserved. <abbr title="World Wide Web Consortium">W3C</abbr> <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

<hr>

<h2 id="abstract">Abstract</h2>

<p>This specification describes a method that enables applications to take advantage of persistent background processing, including hooks to enable bootstrapping of web applications while offline.</p>

<p>The core of this system is an event-driven <a href="http://www.w3.org/TR/workers/">Web Worker</a>, which responds to events dispatched from documents and other sources. A system for managing installation, versions, and upgrades is provided.</p>

<p>The Service Worker is a generic entry point for event-driven background processing in the Web Platform that is <a href="#extensibility">extensible by other specifications</a>.</p>

<h2 id="status">Status of This Document</h2>

<p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current <abbr title="World Wide Web Consortium">W3C</abbr> publications and the latest revision of this technical report can be found in the <a href="http://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr> technical reports index</a> at http://www.w3.org/TR/.</em></p>

<p>This document was published by the <a href="http://www.w3.org/2008/webapps/">Web Applications Working Group</a> as an Editor's Draft. If you wish to make comments regarding this document, please send them to <a href="mailto:public-webapps@w3.org">public-webapps@w3.org</a> (<a href="mailto:public-webapps-request@w3.org?subject=subscribe">subscribe</a>, <a href="http://lists.w3.org/Archives/Public/public-webapps/">archives</a>). All feedback is welcome.</p><p>Publication as an Editor's Draft does not imply endorsement by the <abbr title="World Wide Web Consortium">W3C</abbr> Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.</p>

<p>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>. <abbr title="World Wide Web Consortium">W3C</abbr> maintains a <a href="http://www.w3.org/2004/01/pp-impl/45559/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the <abbr title="World Wide Web Consortium">W3C</abbr> Patent Policy</a>.</p>

</div>

<section class="toc">
<h2 id="toc">Table of Contents</h2>
<ol>
    <li><a href="#introduction">Introduction</a>
    <ol>
        <li><a href="#about">About this Document</a></li>
        <li><a href="#dependencies">Dependencies</a></li>
        <li><a href="#motivations">Motivations</a></li>
        <li><a href="#concepts">Concepts</a></li>
        <li><a href="#offline-example">Example: Offline Web Applications</a></li>
    </ol></li>

    <li><a href="#service-worker-lifecycle">Service Worker Lifecycle</a>
    <ol>
        <li><a href="#registration">Registration</a></li>
        <li><a href="#event-handling">Event Handling</a></li>
        <li><a href="#installation">Installation</a>
            <ol><li><a href="#worker-script-caching">Worker Script Fetch &amp;Caching</a></li></ol>
        </li>
        <li><a href="#activation">Activation</a></li>
        <li><a href="#navigation-matching">Navigation Matching</a>
        <li><a href="#fetch-handling">Fetch Handling</a>
        <li><a href="#lifetime-extension">Lifetime Extension</a></li>
        <li><a href="#upgrade">Upgrade</a></li>
    </ol></li>

    <li><a href="#document-context">Document Context</a>
    <ol>
        <li><a href="#service-worker-obj"><code>ServiceWorker</code></a></li>
        <li><a href="#navigator-service-worker"><code>navigator.serviceWorker</code></a>
        <ol>
            <li><a href="#navigator-service-worker-active"><code>active</code></a></li>
            <li><a href="#navigator-service-worker-getAll"><code>getAll()</code></a></li>
            <li><a href="#navigator-service-worker-register"><code>register()</code></a></li>
            <li><a href="#navigator-service-worker-unregister"><code>unregister()</code></a></li>
            <li><a href="#navigator-service-worker-oninstall"><code>oninstall</code></a></li>
            <li><a href="#navigator-service-worker-oninstallend"><code>oninstallend</code></a></li>
            <li><a href="#navigator-service-worker-onactivate"><code>onactivate</code></a></li>
            <li><a href="#navigator-service-worker-onactivateend"><code>onactivateend</code></a></li>
            <li><a href="#navigator-service-worker-onreloadpage"><code>onreloadpage</code></a></li>
            <li><a href="#navigator-service-worker-onerror"><code>onerror</code></a></li>
        </ol></li>
    </ol></li>

    <li><a href="#execution-context">Execution Context</a>
    <ol>
        <li><a href="#service-worker-global-scope"><code>ServiceWorkerGlobalScope</code></a>
        <ol>
            <li><a href="#service-worker-global-scope-caches"><code>caches</code></a></li>
            <li><a href="#service-worker-global-scope-clients"><code>clients</code></a></li>
            <li><a href="#service-worker-global-scope-scope"><code>scope</code></a></li>
            <li><a href="#service-worker-global-scope-fetch"><code>fetch(request)</code></a></li>
            <li><a href="#service-worker-global-scope-update"><code>update()</code></a></li>
            <li><a href="#service-worker-global-scope-unregister"><code>unregister()</code></a></li>
            <li><a href="#service-worker-global-scope-onmessage"><code>onmessage</code></a></li>
        </ol></li>
        <li><a href="#request-objects"><code>Request</code> Objects</a></li>
        <li><a href="#response-objects"><code>Response</code> Objects</a>
        <ol>
            <li><a href="#abstract-response"><code>AbstractResponse</code></a></li>
            <li><a href="#response"><code>Response</code></a></li>
            <li><a href="#opaque-response"><code>OpaqueResponse</code></a></li>
            <li><a href="#cors-response"><code>CORSResponse</code></a></li>
        </ol>
        </li>
        <li><a href="#fetch"><code>fetch()</code></a></li>
        <li><a href="#cache-objects">Caches</a>
        <ol>
            <li><a href="#cache-lifetimes">Cache Lifetime Semantics</a></li>
            <li><a href="#cache"><code>Cache</code></a></li>
            <li><a href="#async-map"><code>AsyncMap</code></a></li>
            <li><a href="#cache-list"><code>CacheList</code></a></li>
        </ol>
        </li>
        <li><a href="#client"><code>Client</code></a>
            <ol><li><a href="#service-worker-clients"><code>ServiceWorkerClients</code></a></li></ol>
        </li>
        <li><a href="#events">Events</a>
        <ol>
            <li><a href="#install-phase-event"><code>InstallPhaseEvent</code></a></li>
            <li><a href="#oninstall"><code>oninstall</code></a>
                <ol><li><a href="#install-event"><code>InstallEvent</code></a></li></ol>
            </li>
            <li><a href="#onactivate"><code>onactivate</code></a>
                <ol><li><a href="#activate-event"><code>ActivateEvent</code></a></li></ol>
            </li>
            <li><a href="#onfetch"><code>onfetch</code></a>
                <ol><li><a href="#fetch-event"><code>FetchEvent</code></a></li></ol>
            </li>
        </ol></li>
    </ol></li>

    <li><a href="#security-considerations">Security Considerations</a>
    <ol>
        <li><a href="#origin-relativity">Origin Relativity</a></li>
        <li><a href="#x-origin-resources">Cross-Origin Resources & CORS</a></li>
    </ol></li>
    <li><a href="#storage-considerations">Storage Considerations</a></li>
    <li><a href="#extensibility">Extensibility</a></li>
    <li><a href="#appendix-a">Appendix A: Algorithms</a></li>
    <li><a href="#acknowledgements" class="no-number">Acknowledgements</a></li>

</ol>

</section>

<section class="spec">

<h2 id="introduction">Introduction</h2>

<h3 id="about">About this Document</h3>

<p>All diagrams, examples, notes, are non-normative, as well as sections explicitly marked as non-normative. Everything else in this specification is normative.</p>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in the normative parts of this document are to be interpreted as described in <a href="http://dev.w3.org/2006/xbl2/#refsRFC2119">RFC2119</a>. For readability, these words do not appear in all uppercase letters in this specification.</p>

<p>Any point, at which a conforming UA must make decisions about the state or reaction to the state of the conceptual model, is captured as <a href="http://en.wikipedia.org/wiki/Algorithm">algorithm</a>. The algorithms are defined in terms of processing equivalence. The <dfn id="dfn-processing-equivalence">processing equivalence</dfn> is a constraint imposed on the algorithm implementors, requiring the output of the both UA-implemented and the specified algorithm to be exactly the same for all inputs.</p>

<h3 id="dependencies">Dependencies</h3>

<p>This document relies on the following specifications:</p>

<ul>
    <li><a href="http://www.w3.org/TR/workers/">Web Workers</a></li>
    <li><a href="http://fetch.spec.whatwg.org/">Fetch Living Standard</a></li>
    <li><a href="http://dom.spec.whatwg.org/">DOM Living Standard</a></li>
    <li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">HTML Living Standard</a></li>
    <li><a href="http://ecma-international.org/ecma-262/5.1/">ECMAScript Language Specification</a></li>
    <li><a href="http://www.w3.org/TR/WebIDL/">Web IDL</a></li>
    <li><a href="http://www.w3.org/TR/IndexedDB/">Indexed DB</a></li>
    <li><a href="http://www.w3.org/TR/quota-api/">Quota Management API</a></li>
    <li><a href="http://www.w3.org/TR/notifications/">Web Notifications</a></li>
    <li><a href="http://tools.ietf.org/html/rfc6454">The Web Origin Concept</a></li>
</ul>

<h3 id="motivations">Motivations</h3>

<div class="informative">
<p>Web Applications traditionally assume that the network is reachable. This assumption pervades the platform. HTML documents are loaded over HTTP and traditionally fetch all of their sub-resources via subsequent HTTP requests. This places web content at a disadvantage versus other technology stacks.<p>

<p>The Service Worker is designed first to redress this balance by providing a Web Worker context, which can be started by a runtime when navigations are about to occur. This event-driven worker is registered against an origin and a path (or pattern), meaning it can be consulted when navigations occur to that location. Events that correspond to network requests are dispatched to the worker and the responses generated by the worker may over-ride default network stack behavior. This puts the Service Worker, conceptually, between the network and a document renderer, allowing the Service Worker to provide content for documents, even while offline.</p>

<p>Web developers familiar with previous attempts to solve the offline problem have reported a deficit of flexibility in those solutions. As a result, the Service Worker is highly procedural, providing a maximum of flexibility at the price of additional complexity for developers. Part of this complexity arises from the need to keep Service Workers responsive in the face of a single-threaded execution model. As a result, APIs exposed by Service Workers are almost entirely asynchronous, a pattern familiar in other JavaScript contexts but accentuated here by the need to avoid blocking document and resource loading.</p>

<p>Developers using the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html">HTML5 Application Cache</a> have also <a href="http://alistapart.com/article/application-cache-is-a-douchebag">reported that several attributes</a> of the design contribute to <a href="http://alistapart.com/article/application-cache-is-a-douchebag#section6">unrecoverable errors</a>. A key design principle of the Service Worker is that errors should <em>always</em> be recoverable. Many details of the update process of Service Workers are designed to avoid these hazards.</p>

<p>Service Workers are started and kept alive by their relationship to events, not documents. This design borrows heavily from developer and vendor experience with <a href="http://www.w3.org/TR/workers/#sharedworker">Shared Workers</a> and <a href="http://developer.chrome.com/extensions/background_pages.html">Chrome Background Pages</a>. A key lesson from these systems is the necessity to time-limit the execution of background processing contexts, both to conserve resources and to ensure that background context loss and restart is top-of-mind for developers. As a result, Service Workers bear more than a passing resemblance to <a href="http://developer.chrome.com/extensions/event_pages.html">Chrome Event Pages</a>, the successor to Background Pages. Service Workers may be started by user agents <em>without an attached document</em> and may be killed by the user agent at nearly any time. Conceptually, Service Workers can be thought of as Shared Workers that can start, process events, and die without ever handling messages from documents. Developers are advised to keep in mind that Service Workers may be started and killed many times a second.</p>

<p>Service Workers are generic, event-driven, time-limited script contexts that run at an origin. These properties make them natural endpoints for a range of runtime services that may outlive the context of a particular document, e.g. handling push notifications, background data synchronization, responding to resource requests from other origins, or receiving centralized updates to expensive-to-calculate data (e.g., geolocation or gyroscope).</p>
</div>

<h3 id="concepts">Concepts</h3>

<p>A <dfn id="service-worker">Service Worker</dfn> is a type of <a href="http://www.w3.org/TR/workers/">Web Worker</a>. Unlike other types of Web Worker, the lifetime of a Service Worker is tied to the execution lifetime of events, not references held by documents to the <a href="#service-worker-obj">worker object</a>. In practice, this means that <a href="#service-worker">Service Workers</a> may begin, end, and restart execution many times over the life of documents which they logically <a href="#docment-control">control</a>.</p>

<p>Service Workers are <a href="#installation">installed</a> by user agents after being <a href="#registration">registered</a> by authors from the context of a <a href="http://dom.spec.whatwg.org/#concept-document">document</a>. Service Workers execute in the registering document's <a href="#FIXME">origin</a>.</p>

<p><a href="#algorithm-registration">Registration</a> maps a <a href="#service-worker">Service Worker</a> script to <dfn id="url-scope">url scope</dfn>, a tuple of <a href="http://tools.ietf.org/html/rfc6454">origin</a> and <a href="#path-expression">path expression</a>. User agents may enable many registrations at a single origin so long as the <a href="#path-expression">path expression</a> of the registration differs. <a href="#algorithm-registration">Registration</a> of an identical <a href="http://tools.ietf.org/html/rfc6454">origin</a>/<a href="#path-expression">path expression</a> when one already exists in the user agent causes the existing registration to be replaced.</p>

<p>A <dfn id="path-expression">path expression</dfn> consists of a <a href="http://url.spec.whatwg.org/#concept-relative-url">relative url</a> which may, optionally, terminate with the charachter <code>"*"</code>. Ending a <a href="#path-expression">path expression</a> with <code>"*"</code> enables <a href="#algorithm-matching">longest-prefix wildcard matching</a>.</p>

<p>A document is "<dfn id="doucment-control">controlled</dfn>" if an <a href="#FIXME">active</a> <a href="#service-worker">Service Worker</a> <a href="#algorithm-matching">matches</a> the doucment's URL upon <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#navigate">navigation</a>. Multiple documents may be concurrently <a href="#document-controlled">controlled</a> by a single <a href="#service-worker">Service Worker</a> instance. That is, <a href="#service-worker">Service Workers</a> have a one-to-many relationship with controlled documents.</p>

<p>The <dfn id="lifecycle-events">Lifecycle events</dfn> of Service Workers are <code><a href="#oninstall">oninstall</a></code> and <code><a href="#onactivate">onactivate</a></code>. <dfn id="functional-events">Functional events</dfn> are <a href="http://dom.spec.whatwg.org/#interface-event">DOM Events</a> that are dispatched in the <a href="#service-worker-global-scope">Service Worker global context</a> which are not <a href="#lifecycle-events">lifecycle events</a> of the Service Worker.</p>

<p>Registered Service Workers do not immediately begin to receive <a href="#functional-events">functional events</a> for documents. Registration is the first step in installation, which proceeds through several phases:</p>

<ol>
    <li><em>Fetch</em>:
    <br>
    The script URL provided by the author (via a call to <a href="#register-service-worker"><code>navigator.serviceWorker.register([script URL], [registration option])</code></a> from a document) is fetched without <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.2.2">heuristic caching</a>. If the return status code of the fetch is not <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2">2xx</a>, installation aborts.</li>
    <li><em>Startup</em>:
    <br>
    If fetching the worker script is successful, it is <a href="http://www.w3.org/TR/workers/#processing-model">executed</a> in a <code><a href="#service-worker-global-scope">ServiceWorkerGlobalScope</a></code>. These scripts may call <code><a href="http://www.w3.org/TR/workers/#importing-scripts-and-libraries">importScripts</a></code> resulting in further fetches. Imported scripts are fetched, <a href="https://people.mozilla.org/~jorendorff/es5.1-final.html#sec-5.1.4">parsed</a> and <a href="https://people.mozilla.org/~jorendorff/es5.1-final.html#sec-10.4.1">executed</a> in turn, per the ECMA-262 and <a href="http://www.w3.org/TR/workers/#importing-scripts-and-libraries">Web Worker specifications</a>. All resources downloaded as part of the very first startup of a Service Worker are cached along with the worker script as described in <a href="#worker-script-caching">"Worker Script Caching"</a>.
    </li>
    <li><em><code>oninstall</code></em>:
    <br>
    Once a Service Worker has been fetched and started, it is ready to process <a href="http://dom.spec.whatwg.org/#interface-event">events</a>. The first event sent to every Service Worker is <a href="#oninstall"><code>oninstall</code></a>. Workers that handle this event are encouraged to use it as a way to prime the available storage mechanisms for supporting offline application use; perhaps by populating <a href="http://www.w3.org/TR/IndexedDB/">IndexedDB databases</a> or <a href="#cache-objects"><code>Cache</code> objects</a>.
    <br><br>
    Service Workers are not considered "installed" until the <code>oninstall</code> event completes. Given that many tasks, such as populating caches, may take a long time and are asynchronous, <a href="#lifetime-extension">mechanisms are provided</a> to let applications signal to the user agent when they consider themselves prepared to handle further events.
    <br><br>
    If no <code>oninstall</code> event handler is registered, the Service Worker is considered to be <dfn id="successfully-installed">successfully installed</dfn>.
    <br><br>
    If any <code>oninstall</code> handler throws an exception, or if any lifetime extension via <code>event.waitUntil()</code> fails (via Promise rejection), installation fails and activation is not carried out.
    <br><br>
    Assuming a worker <a href="#successfully-installed">is successfully installed</a>, it is now considered the <dfn id="worker-in-waiting">worker in waiting</dfn>. There may be only one <a href="#active-worker">active worker</a> and one <a href="#worker-in-waiting">worker in waiting</a> for a given <a href="#url-scope">url scope</a>.
    </li>
    <li><em><code>onactivate</code></em>:
    <br>
    After successful installation and just prior to receiving <a href="#functional-events">functional events</a> (e.g., <code><a href="#onfetch">onfetch</a></code>), the <code>onactivate</code> event is dispatched. The primary use of <code>onactivate</code> is for cleanup of resources used in previous versions of a Service Worker script.
    <br><br>
        <div class="note">Like <code>oninstall</code>, this event may extend its lifetime using <code>event.waitUntil()</code>, however developers should note that activation is particularly performance sensitive. Performance sensitive events may be queued and will be delayed until successful completion of <code>onctivate</code>.</div>
    </li>
</ol>

<p>User Agents may request updated Service Worker scripts "in the background" while controlled documents for an existing Service Worker and url scope are active. Successful fetch, startup, and <code>oninstall</code> <i>do not</i> gaurantee that the <a href="#worker-in-waiting">worker-in-waiting</a> will begin to immediately handle <a href="#functional-events">functional events</a>. An existing Service Worker script will continue to service documents it controls (and will continue to control new documents in the <a href="#url-scope">url scope</a>) so long as any documents it controlled remain. API exists on the <a href="#service-worker-obj">Service Worker</a> to enable immediate activation but this is not the default behavior.<p>

<p>Once a service worker becomes active, the user agent may dispatch <a href="#functional-events">functional events</a>. These events model various user-agent generated operations; for example the <code><a href="#onfetch">onfetch</a></code> event handling HTTP requests.</p>


<!--
<h3 id="offline-example">Example: Offline Web Applications</h3>

<pre><code class="prettyprint">
// TODO(slightlyoff)
</code></pre>

<p></p>
-->

<div class="informative">

<h2 id="service-worker-lifecycle">Service Worker Lifecycle</h2>

<p>The core <a href="#concepts">concepts</a> of the Service Worker related to the lifecycle. Service Workers are <a href="#registration">registered</a>, <a href="#worker-script-caching">fetched</a>, <a href="#installation">installed</a>, and <a href="#activation">activated</a> before <a href="#event-handling">events are dispatched</a> to them.</p>

<h3 id="registration">Registration</h3>

<p></p>

<h3 id="event-handling">Event Handling</h3>

<p></p>

<h3 id="installation">Installation</h3>

<p></p>

<!-- FIXME(slightlyoff): this wording is very unclear. I think we mean to lay out that requests for scripts should hit the cache unless the script is more than 24 hours old, in which case we should issue the request with cache-busting headers. That doesn't come through clearly in the prose. -->
<h4 id="worker-script-caching">Worker Script Fetch &amp; Caching</h4>

<!-- FIXME: need to add discussion of the default cache object to which the script and dependencies are added. For that matter, need to add discussion of dependencies. -->
<p>Upon successful <a href="#FIXME">fetch</a> of a Service Worker, the provided worker <a href="#FIXME">script</a> SHOULD be cached by the UA. The UA SHOULD honor the HTTP cache headers to avoid unnecessary requests per navigation to the <a href"#registration">registered</a> <a href="#url-scope">url scope</a>, but with an upper limit of 24 hours. If no HTTP cache headers are provided for a locally cached script, the request MUST be issued as <code>cache-control: must-revalidate.</code></p>

<p class="note">These headers are for updating the worker only, not using it. The <code>Expires</code> header is ignored in the loading of service worker scripts from the cache.</p>

<p>Under this recommended caching rule, UAs SHOULD check for worker updates on each navigation to the matching <a href="#url-scope">scope</a>, although they MAY do more regular checks (even when the site is not open) for sites it considers important to the user. UAs may not update the worker <a href="#FIXME">script</a> for the documents which are not visited once in the last 24 hours.</p>

<p>Additionally, <code>update()</code> method is provided in the <code><a href="#service-worker-global-scope-interface">ServiceWorkerGlobalScope</a></code> interface to allow a Service Worker to trigger a forced update.</p>

<h3 id="activation">Activation</h3>

<p></p>

<h3 id="navigation-matching">Navigation Matching</h3>

<p></p>

<h3 id="fetch-handling">Fetch Handling</h3>

<p></p>

<h3 id="lifetime-extension">Lifetime Extension</h3>

<p></p>

<h3 id="upgrade">Upgrade</h3>

<p></p>

</div>

<h2 id="document-context">Document Context</h2>

<h3 id="service-worker-obj"><code>ServiceWorker</code></h3>

<p></p>
<pre><code>[Constructor()] // no-op constructor
interface <dfn id="service-worker-interface" title="ServiceWorker">ServiceWorker</dfn> : <a href="http://goo.gl/mkHcfY">Worker</a> {
  readonly attribute DOMString scope;
  readonly attribute DOMString url;
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#service-worker-interface">ServiceWorker</a>&gt; ready();

  // event
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> ondeactivate;
};</code></pre>

<p>The <code>ServiceWorker</code> interface represents the document-side view of a Service Worker. This object provides a no-op constructor. Callers should note that only <code>ServiceWorker</code> objects created by the user agent (see <a href="#navigator-service-worker-active"><code>navigator.serviceWorker.active</code></a>) will provide meaningful functionality.</p>

<p>The <code>scope</code> of a <code>ServiceWorker</code> reflects the scope of the <code>ServiceWorker</code>'s <a href="#registration">registration</a>. For example, consider a document created by a navigation to <code>http://example.com/app.html</code> which <a href="#navigation-matching">matches</a> via the following registration call which has been previously executed:</p>

<pre><code class="prettyprint">// Script on the page http://example.com/app.html
navigator.serviceWorker.register("/service_worker.js", { scope: "*" });</code></pre>

<p>The value of <code>navigator.serviceWorker.active.scope</code> will be <code>"*"</code>.</p>

<p>Similarly, in this example, the value of <code>navigator.serviceWorker.active.url</code> will be <code>"http://example.com/service_worker.js"</code>. The <code>url</code> property is always an <a href="http://url.spec.whatwg.org/#concept-absolute-url">absolute URL</a> corresponding to the script file which the Service Worker evaluates.</p>

<p>The <code>ondeactivate</code> event is fired in a turn following <a href="#replace-method">replacement</a> of the <code>ServiceWorker</code>.</p>

<h3 id="navigator-service-worker"><code>navigator.serviceWorker</code></h3>

<p><code>navigator.serviceWorker</code> is an object which provides access to registration, removal, upgrade, and communication with service workers that are (or will become) active for the current document.</p>

<p>The <code>active</code> property of this object provides a reference to the service worker which was consulted during the construction of the current document (if any).</p>

<p>Communication with these workers is provided via standard <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/web-messaging.html">HTML5 messaging APIs</a>, and <a href="http://www.w3.org/TR/workers/#dom-worker-postmessage">messaging occurs as per usual with Web Workers</a>.</p>

<pre><code>partial interface <a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#navigator-0">Navigator</a> {
  readonly attribute <a href="#service-worker-container-interface">ServiceWorkerContainer</a> serviceWorker;
};

interface <dfn id="service-worker-container-interface" title="ServiceWorkerContainer">ServiceWorkerContainer</dfn> {
  [<a href="http://heycam.github.io/webidl/#Unforgeable">Unforgeable</a>] readonly attribute <a href="#service-worker-interface">ServiceWorker</a>? active;

  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#service-worker-interface">ServiceWorker</a>&gt; ready();
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#service-worker-interface">ServiceWorker</a>[]?&gt; getAll();
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#service-worker-interface">ServiceWorker</a>&gt; register(DOMString <var>url</var>, optional <a href="#registration-option-list-dictionary">RegistrationOptionList</a> <var>options</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#service-worker-interface">ServiceWorker</a>&gt; unregister(DOMString? <var>scope</var>);

  // events
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> oninstall;
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> oninstallend;
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onactivate;
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onactivateend;
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onreloadpage;
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onerror;
};

dictionary <dfn id="registration-option-list-dictionary" title="RegistrationOptionList">RegistrationOptionList</dfn> {
  DOMString scope = "/*";
};

interface <dfn id="reload-page-event-interface" title="ReloadPageEvent">ReloadPageEvent</dfn> : <a href="http://goo.gl/UVs0Yt">Event</a> {
  void waitUntil(<a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; <var>f</var>);
};

interface <dfn id="document-install-phase-event-interface" title="DocumentInstallPhaseEvent">DocumentInstallPhaseEvent</dfn> : <a href="http://goo.gl/UVs0Yt">Event</a> {
  readonly attribute <a href="#service-worker-interface">ServiceWorker</a> worker;
};

interface <dfn id="document-install-event-interface" title="DocumentInstallEvent">DocumentInstallEvent</dfn> : <a href="#document-install-phase-event-interface">DocumentInstallPhaseEvent</a> {
  readonly attribute <a href="#service-worker-interface">ServiceWorker</a> previous;
};
</code></pre>

<h4 id="navigator-service-worker-active"><code>active</code></h4>

<p><code>navigator.serviceWorker.active</code> provides a reference to the <a href="#service-worker"><code>ServiceWorker</code></a></p>

<p><code>navigator.serviceWorker.active</code> is <code>null</code> if the current document was not <a href="#navigation-matching">created under a service worker</a>.</p>


<h4 id="navigator-service-worker-getAll"><code>getAll()</code></h4>
<h4 id="navigator-service-worker-register"><code>register()</code></h4>
<h4 id="navigator-service-worker-unregister"><code>unregister()</code></h4>
<h4 id="navigator-service-worker-oninstall"><code>oninstall</code></h4>
<h4 id="navigator-service-worker-oninstallend"><code>oninstallend</code></h4>
<h4 id="navigator-service-worker-onactivate"><code>onactivate</code></h4>
<h4 id="navigator-service-worker-onactivateend"><code>onactivateend</code></h4>
<h4 id="navigator-service-worker-onreloadpage"><code>onreloadpage</code></h4>
<h4 id="navigator-service-worker-onerror"><code>onerror</code></h4>

<h2 id="execution-context">Execution Context</h2>

<h3 id="service-worker-global-scope"><code>ServiceWorkerGlobalScope</code></h3>

<pre><code>[<a href="http://heycam.github.io/webidl/#Global">Global</a>]
interface <dfn id="service-worker-global-scope-interface" title="ServiceWorkerGlobalScope">ServiceWorkerGlobalScope</dfn> : <a href="http://goo.gl/mkHcfYglobalscope">WorkerGlobalScope</a> {
  readonly attribute <a href="#cache-list-interface">CacheList</a> caches;
  // A container for a list of window objects, identifiable by ID, that
  // correspond to windows (or workers) that are "controlled" by this SW
  readonly attribute <a href="#service-worker-clients-interface">ServiceWorkerClients</a> clients;
  [<a href="http://heycam.github.io/webidl/#Unforgeable">Unforgeable</a>] readonly attribute DOMString scope;

  <a href="#response-promise-interface">ResponsePromise</a>&lt;any&gt; fetch((<a href="#request-interface">Request</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] <a href="http://goo.gl/Kxbl8E">URL</a> or DOMString) <var>request</var>);

  void update();
  void unregister();

  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> oninstall;
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onactivate;
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onfetch;
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onbeforeevicted;
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onevicted;

  // The event.source of these MessageEvents are instances of Client
  attribute <a href="http://goo.gl/3nnYrx">EventHandler</a> onmessage;

  // close() method inherited from WorkerGlobalScope is not exposed.
};
</code></pre>

<p>The <code>ServiceWorkerGlobalScope</code> interface represents the global execution context of a Service Worker. <code>ServiceWorkerGlobalScope</code> object provides generic, event-driven, time-limited script execution contexts that run at an origin. Once successfully <a href="#registration">register</a>ed, a Service Worker is started, kept alive and killed by their relationship to events, not documents. Any type of synchronous requests MUST NOT be initiated inside of a Service Worker.</p>

<h4 id="service-worker-global-scope-caches"><code>caches</code></h4>
<h4 id="service-worker-global-scope-clients"><code>clients</code></h4>
<h4 id="service-worker-global-scope-scope"><code>scope</code></h4>
<h4 id="service-worker-global-scope-fetch"><code>fetch(request)</code></h4>
<h4 id="service-worker-global-scope-update"><code>update()</code></h4>

<p>Ping the server for an updated version of this script without consulting caches. (See the <a href="#update-algorithm">Service Woker Update Algorithm</a>.)</p>

<h4 id="service-worker-global-scope-unregister"><code>unregister()</code></h4>
<h4 id="service-worker-global-scope-onmessage"><code>onmessage</code></h4>

<h3 id="request-objects"><code>Request</code> Objects</h3>

<pre><code>
interface <dfn id="request-promise-interface" title="RequestPromise">RequestPromise</dfn> : <a href="http://goo.gl/3TobQS">Promise</a> {
};

[Constructor(optional <a href="#request-init-dictionary">RequestInit</a> <var>init</var>)]
interface <dfn id="request-interface" title="Request">Request</dfn> {
  attribute unsigned long timeout;
  attribute DOMString url;
  attribute <a href="http://goo.gl/M46tpy">ByteString</a> method;
  readonly attribute DOMString origin;
  readonly attribute <a href="#mode-dictionary">Mode</a> mode;
  attribute boolean synchronous;
  readonly attribute unsigned long redirectCount;
  attribute boolean forcePreflight;
  attribute boolean omitCredentials;
  readonly attribute <a href="http://goo.gl/Kxbl8E">URL</a> referrer;
  readonly attribute <a href="#header-map-interface">HeaderMap</a> headers; // alternative: sequence&lt;Header&gt; headers;
  attribute any body;
};

dictionary <dfn id="request-init-dictionary" title="RequestInit">RequestInit</dfn> {
  unsigned long timeout = 0;
  DOMString url;
  boolean synchronous = false;
  boolean forcePreflight = false;
  boolean omitCredentials = false;
  <a href="http://goo.gl/M46tpy">ByteString</a> method = "GET";
  <a href="#header-map-interface">HeaderMap</a> headers;
  any body;
};

enum <dfn id="mode-enum" title="Mode">Mode</dfn> {
  "same origin",
  "tainted x-origin",
  "CORS"
};

[<a href="http://goo.gl/lJQaAt">MapClass</a>(DOMString, DOMString)]
interface <dfn id="header-map-interface" title="HeaderMap">HeaderMap</dfn> {
};
</code></pre>

<h3 id="response-objects"><code>Response</code> Objects</h3>

<p><code>Resposne</code> objects model HTTP responses.</p>

<pre><code>
interface <dfn id="response-promise-interface" title="ResponsePromise">ResponsePromise</dfn> : <a href="http://goo.gl/3TobQS">Promise</a> {
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="http://goo.gl/dqRadv">Blob</a>&gt; toBlob();
};

[Constructor]
interface <dfn id="abstract-response-interface" title="AbstractResponse">AbstractResponse</dfn> {
};

interface <dfn id="opaque-response-interface" title="OpaqueResponse">OpaqueResponse</dfn> : <a href="#abstract-response-interface">AbstractResponse</a> {
  readonly attribute unsigned short statusCode;
  readonly attribute <a href="http://goo.gl/M46tpy">ByteString</a> statusText;
  readonly attribute <a href="http://goo.gl/M46tpy">ByteString</a> method;
  // Returns a filtered list of headers. See <a href="#opaque-response">prose for details</a>.
  getter <a href="#header-map-interface">HeaderMap</a> headers();
  // No setter for headers
  readonly DOMString url;
};

interface <dfn id="cors-response-interface" title="CORSResponse">CORSResponse</dfn> : <a href="#response-interface">Response</a> {
  getter <a href="#header-map-interface">HeaderMap</a> headers();
};

[Constructor(optional <a href="#response-init-dictionary">ResponseInit</a> <var>responseInitDict</var>)]
interface <dfn id="response-interface" title="Response">Response</dfn> : <a href="#abstract-response-interface">AbstractResponse</a> {
  attribute unsigned short statusCode;
  attribute <a href="http://goo.gl/M46tpy">ByteString</a> statusText;
  attribute <a href="http://goo.gl/M46tpy">ByteString</a> method;
  getter <a href="#header-map-interface">HeaderMap</a> headers();
  setter void headers(<a href="#header-map-interface">HeaderMap</a> items);
  DOMString url;
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="http://goo.gl/dqRadv">Blob</a>&gt; toBlob();
};

dictionary <dfn id="response-init-dictionary" title="ResponseInit">ResponseInit</dfn> {
  unsigned short statusCode = 200;
  <a href="http://goo.gl/M46tpy">ByteString</a> statusText = "OK";
  <a href="http://goo.gl/M46tpy">ByteString</a> method;
  <a href="#header-map-interface">HeaderMap</a> headers;
};
</code></pre>

<h4 id="abstract-response"><code>AbstractResponse</code></h4>

<p><code>AbstractResponse</code> is a superclass for all <code>Resposne</code> types. It should not be directly constructed (although, for compatibility with JavaScript, a constructor is provided).</p>

<h4 id="response"><code>Response</code></h4>

<p><code>Response</code> objects are mutable and constructable. They model HTTP responses. The <code>fetch()</code> API returns this type for same-origin responses.</p>

<p class="note">It may be possible to set the <code>Location</code> header of a <code>Response</code> object to someplace not in the current origin but this is not a security issue. Cross-origin response bodies are opaque to script, and since only same-origin documents will encounter these responses, the only systems the Service Worker can "lie to" are same-origin (and therefore safe from the perspective of other origins).</p>

<!-- TODO(slightlyoff): whitelist readable headers -->
<p><code>headers</code></p>

<h4 id="opaque-response"><code>OpaqueResponse</code></h4>

<p><code>OpaqueResponse</code> objects are immutable but constructable. The <code>fetch()</code> API returns this type for cross-origin responses.</p>

<p>Their role is to encapsulate the security properties of the web platform. As such, their <code>body</code> attribute will always be <code>undefined</code> and the list of readable <code>headers</code> is heavily filtered.</p>

<p><code>OpaqueResponse</code> objects may be forwarded on to rendering documents in exactly the same way as mutable <code>Response</code> objects.</p>

<!-- TODO(slightlyoff): whitelist readable headers -->

<h4 id="cors-response"><code>CORSResponse</code></h4>

...

<h3 id="fetch"><code>fetch()</code></h3>

...

<h3 id="cache-objects">Caches</h3>

...

<h4 id="cache-lifetimes">Understanding Cache Lifetimes</h4>

...

<h4 id="cache"><code>Cache</code></h4>

<pre><code>
[Constructor((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString)... <var>urls</var>)]
interface <dfn id="cache-interface" title="Cache">Cache</dfn> {
  readonly attribute <a href="#async-map-interface">AsyncMap</a> items;

  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#response-interface">Response</a>&gt; match((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString) <var>name</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; add((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString)... <var>responses</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; addResponse((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString) <var>url</var>, <a href="#response-interface">Response</a> <var>response</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; remove((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString)... <var>responses</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; update((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString)... <var>urls</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; ready();
};
</code></pre>

<h4 id="async-map"><code>AsyncMap</code></h4>

<pre><code>
[<a href="http://goo.gl/lJQaAt">MapClass</a>(DOMString, <a href="#response-interface">Response</a>)]
interface <dfn id="async-map-interface" title="AsyncMap">AsyncMap</dfn> {
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#response-interface">Response</a>&gt; get(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;boolean&gt; has(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; set(DOMString <var>key</var>, <a href="#response-interface">Response</a> <var>val</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; clear();
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; delete(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any?&gt; items();
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;DOMString[]?&gt; keys();
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#response-interface">Response</a>[]?&gt; values();
};
</code></pre>

<p><span class="fixme"><strong>Issue</strong>: the following issues should be addressed in the WebIDL specification: the methods <code>keys()</code> and <code>values()</code> are not allowed to be declared as interface members of an interface declared with the [<a class="external" href="http://goo.gl/lJQaAt">MapClass</a>] extended attribute; the return type of <code>get(key)</code>, <code>has(key)</code>, <code>set(key, val)</code>, <code>clear()</code>, <code>delete(key)</code> is meant to be declared as pre-defined IDL fragment. Namely, the interface declared with [<a class="external" href="http://goo.gl/lJQaAt">MapClass</a>] extended attribute cannot fully support creating asynchronous map objects.</span></p>

<h4 id="cache-list"><code>CacheList</code></h4>

<pre><code>
[<a href="http://goo.gl/lJQaAt">MapClass</a>(DOMString, <a href="#cache-interface">Cache</a>)]
interface <dfn id="cache-list-interface" title="CacheList">CacheList</dfn> {
  <a href="#response-promise-interface">ResponsePromise</a>&lt;any&gt; match(DOMString <var>name</var>, (<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString) <var>url</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#cache-interface">Cache</a>&gt; get(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;boolean&gt; has(DOMString <var>key</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; set(DOMString <var>key</var>, <a href="#cache-interface">Cache</a> <var>val</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; clear();
  <a href="#cache-list-interface">CacheList</a> items();
  DOMString[] keys();
  <a href="#cache-interface">Cache</a>[] values();
  getter unsinged long size();
};
</code></pre>

<h3 id="client"><code>Client</code></h3>

<pre><code>[Constructor()] // no-op constructor
interface <dfn id="client-interface" title="Client">Client</dfn> {
  readonly attribute unsigned long id;
  void postMessage(any <var>message</var>, DOMString <var>targetOrigin</var>,
                   optional sequence&lt;<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#transferable">Transferable</a>&gt; <var>transfer</var>);
};
</code></pre>

<p>The <code>Client</code> interface represents the window or the worker (defined as client) that is controlled by the Service Worker. This object provides a no-op constructor. Callers should note that only <code>Client</code> objects created by the user agent (see <a href="#FIXME"><code>this.clients.getServiced()</code></a>) will provide meaningful functionality.</p>

<p>The <code>id</code> of a <code>Client</code> identifies the specific client object from the list of client objects serviced by the Service Worker. The <code>postMessage(message, targetOrigin, transfer)</code> method of a <code><a href="#client-interface">Client</a></code>, when called, causes a <code><a href="#FIXME">MessageEvent</a></code> to be dispatched at the client object.</p>

<h4 id="service-worker-clients"><code>ServiceWorkerClients</code></h4>

<pre><code>interface <dfn id="service-worker-clients-interface" title="ServiceWorkerClients">ServiceWorkerClients</dfn> {
  // A list of client objects, identifiable by ID, that correspond to windows
  // (or workers) that are "controlled" by this SW
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#client-interface">Client</a>[]?&gt; getServiced();
};
</code></pre>

<p>The <code>ServiceWorkerClients</code> interface represents a container for a list of <code><a href="#client-interface">Client</a></code> objects. The <code>getServiced()</code> method of a <code>ServiceWorkerClients</code>, when called, returns a <a href="http://goo.gl/3TobQS">Promise</a> that will resolve with a list of <code><a href="#client-interface">Client</a></code> objects that are controlled by this Service Worker.</p>

<h3 id="events">Events</h3>

...

<h4 id="install-phase-event"><code>InstallPhaseEvent</code></h4>

<pre><code>
interface <dfn id="install-phase-event-interface" title="InstallPhaseEvent">InstallPhaseEvent</dfn> : <a href="http://goo.gl/UVs0Yt">Event</a> {
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; waitUntil(<a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; <var>f</var>);
};
</code></pre>

<h4 id="oninstall"><code>oninstall</code></h4>

...

<h5 id="install-event"><code>InstallEvent</code></h5>

<pre><code>
interface <dfn id="install-event-interface" title="InstallEvent">InstallEvent</dfn> : <a href="#install-phase-event-interface">InstallPhaseEvent</a> {
  readonly attribute <a href="#service-worker-interface">ServiceWorker</a> activeWorker;
  void replace();
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; reloadAll();
};
</code></pre>

<h5 id="replace-method"><code>event.replace()</code></h5>
<p>This interacts with <code>waitUntil</code> method in the following way:</p>
<ul>
  <li>Replacement only happens upon successful installation</li>
  <li>Successful installation can be delayed by <code>waitUntil</code>, perhaps by subsequent event handlers.</li>
  <li>Therefore, replace does not happen immediately.</li>
</ul>

<h4 id="onactivate"><code>onactivate</code></h4>

...

<h5 id="activate-event"><code>ActivateEvent</code></h5>

...

<h4 id="onfetch"><code>onfetch</code></h4>

...

<h5 id="fetch-event"><code>FetchEvent</code></h5>

<pre><code>
[Constructor]
interface <dfn id="fetch-event-interface" title="FetchEvent">FetchEvent</dfn> : <a href="http://goo.gl/UVs0Yt">Event</a> {
  readonly attribute <a href="#request-interface">Request</a> request;
  readonly attribute Client client; // The window issuing the request.
  readonly attribute <a href="#purpose-enum">Purpose</a> purpose;
  readonly attribute boolean isReload;

  void respondWith(<a href="http://goo.gl/3TobQS">Promise</a>&lt;<a href="#response-interface">Response</a>&gt; <var>r</var>);
  <a href="http://goo.gl/3TobQS">Promise</a>&lt;any&gt; forwardTo((<a href="http://goo.gl/Kxbl8E">URL</a> or [<a href="http://goo.gl/VdmjMo">EnsureUTF16</a>] DOMString) <var>url</var>);
};

enum <dfn id="purpose-enum" title="Purpose">Purpose</dfn> {
    "connect",
    "font",
    "img",
    "object",
    "script",
    "style",
    "worker",
    "popup",
    "child",
    "navigate"
};
</code></pre>

<h5 id="respond-with-method"><code>event.respondWith(r)</code></h5>
<p>The <var>r</var> argument must resolve with a <a href="#response-interface">Response</a>, else a <a href="http://w3c.github.io/dom/#networkerror">NetworkError</a> is thrown. If the request is a top-level navigation and the return value is a <a href="#opaque-response-interface">OpaqueResponse</a> (an opaque response body), a <a href="http://w3c.github.io/dom/#networkerror">NetworkError</a> is thrown. The final URL of all successful (non network-error) responses is the <a href="#request-objects">request</a>ed URL. Renderer-side security checks about tainting for x-origin content are tied to the transparency (or opacity) of the <a href="#response-interface">Response</a> body, not URLs.</p>

<h5 id="is-reload-attribute"><code>event.isReload</code></h5>
<p>Returns true if <var>event</var> was dispatched with the user's intention for the page reload, and false otherwise. Pressing the refresh button should be considered a reload while clicking a link and pressing the back button should not. The behavior of the <var>Ctrl+l enter</var> is left to the implementations of the user agents.</p>

<h2 id="security-considerations">Security Considerations</h2>

...

<h3 id="origin-relativity">Origin Relativity</h3>

...

<h3 id="x-origin-resources">Cross-Origin Resources & CORS</h3>

...


<h2 id="storage-considerations">Storage Considerations</h2>

...

<h2 id="extensibility">Extensibility</h2>

...


<h2 id="appendix-a">Appendix A: Algorithms</h2>

<h3 id="registration-algorithm">Registration</h3>

<p>The <a href="#registration-algorithm">Service Worker Registration Algorithm</a> creates or updates a <a href="#FIXME">registration</a> for some amount of <a href="#url-scope">url scope</a>. If successful, a registration ties the provided <a href="#FIXME">script</a> to an <a href="#FIXME">origin</a> + <a href="#FIXME">scope</a> pair which is subsequently consulted by the user for <a href="#navigation-matching-algorithm">navigation matching</a>.</p>

<!--
<div class="informative">
<p>The following pseudo-code outlines the algorithm somewhat more tersely than the long-form prose steps outlined below. Functions whose names begin with "_" are not defined and are intended to operate in the obvious way with regards to their linked algorithms.</p>

<pre><code class="prettyprint">
navigator.serviceWorker.register = function(url, options) {
    var currentURL = new URL(window.location, document.baseURI);
    var outcome = new Promise()
}
</code></pre>
</div>
 -->

<div class="algorithm">
<dl>
<dt>Input</dt>
    <dd><var>SCRIPT</var>, the URL of the script to register; a string</dd>
    <dd><var>ORIGIN</var>, the origin of the registering document</dd>
    <dd><var>SCOPE</var>, a string representing a <a href="#FIXME">relative URL pattern</a></dd>
<dt>Output</dt>
    <dd><var>PROMISE</var>, a <a href="http://goo.gl/3TobQS">promise</a> whose resolution indicates the success or failure of the algorithm</dd>
</dl>
<ol>
    <li>Let <var>PROMISE</var> be a newly-created <a href="http://goo.gl/3TobQS">promise</a>.</li>
    <li>Return <var>PROMISE</var>.</li>
    <li>Run the following steps asynchronously:
      <ol>
        <li>If the origin of <var>SCRIPT</var> is not the same as the origin of the current document:
          <ol>
            <li>Reject <var>PROMISE</var> rejected with <code>TypeError</code>.</li>
          </ol>
        </li>
        <li>Set the <var><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/fetching-resources.html#fetch">force same origin</a></var> flag.</li>
        <li>Set the <var>cache-busting</var> headers if the last update from the server occured more than 24 hours ago.</li>
        <li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/fetching-resources.html#fetch">Fetch</a> the script from <var>SCRIPT</var>.</li>
        <li>If the response is not success:
          <ol>
            <li>Reject <var>PROMISE</var> with a <code>DOMException</code> whose name is <code>NetworkError</code>.</li>
          </ol>
        </li>
        <li><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html#processing-model-7">Run a worker</a> (per steps 5 and 6) for the fetched script with <var>SCRIPT</var>.</li>
        <li>If any error is encountered:
          <ol>
            <li>Reject <var>PROMISE</var> with a <code>DOMException</code> whose name is <code>InvalidStateError</code>.</li>
          </ol>
        </li>
        <li>Fire an event named <code>install</code> on the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#global-object">global object</a> that is a <code>ServiceWorkerGlobalScope</code> object.</li>
        <li>Fire an event named <code>install</code> on <code>navigator.serviceWorker</code> for all documents which <a href="#navigation-matching">most specifically match</a> <var>ORIGIN</var> + <var>SCOPE</var>.</li>
        <li>If an exception is thrown by any handler:
          <ol>
            <li>Fire an event named <code>error</code> on the <code>navigator.serviceWorker</code> in all documents which <a href="#navigation-matching">most specifically match</a> <var>ORIGIN</var> + <var>SCOPE</var>.</li>
            <li>Reject <var>PROMISE</var> with the exception.</li>
          </ol>
        </li>
        <li>If any handler calls <code>waitUntil</code>:
          <ol>
            <li><a href="#FIXME">Extend the install process</a> until they all resolve.</li>
            <li>If any extension handlers are rejected:
              <ol>
                <li>Fire an event named <code>error</code> on the <code>navigator.serviceWorker</code> in all documents which <a href="#navigation-matching">most specifically match</a> <var>ORIGIN</var> + <var>SCOPE</var>.</li>
                <li>Reject <var>PROMISE</var> with the exception.</li>
              </ol>
            </li>
            <li>If all extension handlers resolve successfully:
              <ol>
                <li>Resolve <var>PROMISE</var> with a newly-created associated Service Worker object.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>If no extension handlers are registered:
          <ol>
            <li>Resolve <var>PROMISE</var> with a newly-created associated Service Worker object.</li>
          </ol>
        </li>
        <li>Fire an event named <code>installend</code> on the <code>navigator.serviceWorker</code> in all documents which <a href="#navigation-matching">most specifically match</a> <var>ORIGIN</var> + <var>SCOPE</var>.</li>
        <li>Set the <var>worker in waiting</var> flag on the installed worker and run the <a href="#FIXME">check-worker-in-waiting</a> algorithm.</li>
      </ol>
    </li>

<!--
The steps are:
    * check the script URL for same-origin-ness with the current document
        * if x-origin, reject and return
        * if same-origin, continue
    * fetch the script with the force same-origin flag set (see: http://www.whatwg.org/specs/web-apps/current-work/multipage/fetching-resources.html#fetch)
        * if the last update from the server occured more than 24 hours ago, fetch the script with cache-busting headers
        * if the response isn't success, reject and return
    * if the script is successfully fetched, start the worker (per http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html#processing-model-7, steps 5 and 6)
        * if any error is encountered, reject and return
    * fire the "oninstall" event on the SW and on navigator.serviceWorker for all documents which most specifically match origin+scope
        * if an exception is thrown by any handler, reject and set the installenderror flag
        * if any handler calls waitUntil, extend the install process until they all resolve.
            * if any extension handlers are rejected, reject and set the installenderror flag
            * if all extension handlers resolve successfully, resolve succesfully
        * if no extension handlers are registered, resolve successfully
    * fire "oninstallend" against navigator.serviceWorker in all documents which most-specifically match origin+scope
        * FIXME: what to do about the event object in the case of errors here?
    * if the installenderror flag is true:
        * dispatch onerror against navigator.serviceWorker in all documents which most specifically match origin+scope
        * return and exit
    * set the "workerinwaiting" flag on the installed worker and run the check-worker-in-waiting algorithm
<script>

</script>
 -->
<!--
     <li>Let <var>PROTOTYPE</var> be the <a href="#dfn-custom-element-prototype">custom element prototype</a> in <var>ELEMENT</var>'s <a href="#dfn-element-definition">definition</a></li>
    <li>Set the value of the <code>[[Prototype]]</code> <a href="http://es5.github.io/#x8.6.2">internal property</a> of <var>ELEMENT</var> to <var>PROTOTYPE</var>.</li>
    <li>If <var>ELEMENT</var> is <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/infrastructure.html#in-a-document">in a document</a> and this <a href="http://dom.spec.whatwg.org/#concept-document">document</a> has a <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#browsing-context">browsing context</a>:
    <ol>
        <li><a href="#dfn-enqueue-lifecycle-callback">Enqueue</a> <a href="#dfn-entered-view-callback"><em>enteredView</em></a> callback for <var>ELEMENT</var></li>
    </ol></li>
 -->
</ol>
</div>

<h3 id="installation-algorithm">Installation</h3>

<h3 id="update-algorithm">Update</h3>

<h3 id="replacement-algorithm">Replacement</h3>

<h3 id="navigation-matching-algorithm">Navigation Matching</h3>

<h3 id="unregistration-algorithm">Unregistration</h3>

</section>

<!-- FIXME: INCOMPLETE!! Please add collaborators below. -->
<h2 id="acknowledgements">Acknowledgements</h2>

<p>Jake Archibald is a ghost-author of this document. The best instincts in the design are his. He similarly shaped many of the details through discussion and experimentation. The bits which are not his (but which are good) owe everything to his experience, persistence, and focus on enabling web developers. He embodies a hopeful example for developers in shaping browser efforts to more directly address real-world pain points. If Service Workers solve "offline for the web", the credit is due him.</p>

<p>Deep thanks go to Andrew Betts for organizing and hosting a small workshop of like-minded individuals including: Jake Archibald, Jackson Gabbard, Tobie Langel, Robin Berjon, Patrick Lauke, Christian Heilmann. From the clarity of the day's discussions and the use-cases outlined there, much has become possible. Further thanks to Andrew for raising consciousness about the offline problem. His organization of EdgeConf and inclusion of Offline as a persistent topic there has created many opportunities and connections that have enabled this work to progress.</p>

<p>Anne van Kesteren has generously lent his encyclopedic knowledge of Web Platform arcana and standards development experience throught the development of the Service Worker. This specification would be incomplete without his previous work in describing the real-world behavior of URLs, HTTP Fetch, Promises, and DOM. Similarly, this specification would not be possible without Ian Hickson's rigorous Web Worker spec. Much thanks to him.</p>

<p>In no particular order, deep gratitude for design guidance and discussion goes to: Junkee Song, Alec Flett, David Barrett-Kahn, Aaron Boodman, Michael Nordman, Tom Ashworth, Kinuko Yasuda, Darin Fisher, Jonas Sicking, Jesús Leganés Combarro, Mark Christian, Dave Hermann, Yehuda Katz, François Remy, Ilya Grigorik, Will Chan, Domenic Denicola, Nikhil Marathe, Yves Lafon, Adam Barth, Greg Simon, and Devdatta Akhawe.</p>

<p>Jason Weber, Chris Wilson, Paul Kinlan, Ehsan Akhgari, and Daniel Austin have provided valuable, well-timed feedback on requirements and the standardization process.</p>

<p>The authors would also like to thank Dimitri Glazkov for his scripts and formatting tools which have been essential in the production of this specification. The authors are also grateful for his considerable guidance.</p>

<p>Thanks also to Vivian Cromwell, Greg Simon, and Alex Komoroske for their considerable professional support.</p>
</body>
</html>
